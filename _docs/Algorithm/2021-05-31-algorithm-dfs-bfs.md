---
title: "DFS, BFS"
category: Algorithm
date: 2020-05-31 17:01:47
comments: true
order: 1
---

## 1. 사전 지식

#### 스택

- FILO

#### 큐

- FIFO

#### 재귀함수

- 재귀 함수의 종료 조건 명시 필요
- 유클리드 호제법
- 스택 대신에 재귀 사용하는 경우 많음 => 함수 연속 호출 - 컴퓨터 메모리의 스택에 쌓임

## 2. DFS

1. 루트 노드에서 시작해서 **다음 분기로 넘어가기전에 해당 분기 완벽 탐색**

2. 미로 탐색할 때, 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면

   다시 가장 가까운 갈림길로 돌아와 이곳으로부터 다른 방향 다시 탐색

3. 즉 넓게 탐색하기 전에 깊게 탐색
4. **모든 노드 방문하고자 할때 사용**
5. dfs가 bfs보다 간단
6. bfs에 비해 느림

#### 장점
- 현 겅로상의 노드 기억하므로 적은 메모리 사용
- 찾으려는 노드가 깊은 단계에 있으면, bfs보다 빠르게 찾기 가능

#### 단점
- 해가 없는 경로 탐색할 경우 무한 루프 빠짐 -> 임의로 깊이 지정 필요

#### 특징

  - **재귀하는 순환 알고리즘**

  - 시간 복잡도 

  ~~~
   그래프(정점수 : n, 간선 수 : e)의 모든 간선 조회
   - 인접 리스트로 표현된 그래프 : O(N+E)
   - 인접 행렬로 표현된 그래프 : O(N^2) (이차배열)
  ~~~

#### DFS 탐색 과정 & 소스

- 깊이 우선 탐색
- 스택 자료구조를 이용
  - 1) 탐색 시작 노드를 스택에 삽입하고 방문 처리
  - 2) 스택의 최상단 노드에 방문하지 않은 인접 노드 있으면 스택에 넣고 방문 처리, **방문하지 않은 인접노드 없다면 스택에서 최상단 노드 꺼내기**
  - 3) 2번의 과정을 수행할 수없을 때까지 반복
  
~~~ python
  def dfs(graph, v, visited):
  # 현재 노드를 방문 처리
  visited[v] = True
  print(v, end=' ')
  # 재귀 방문 연결노드
  for i in graph[v]:
      if not visited[i]:
          dfs(graph, i ,visited)

  graph = [ # []은 0번 노드
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
  ]

  visited = [False]*9

  dfs(graph, 1, visited)

  ## 1 2 7 6 8 3 4 5  =>  스택에 들어간 순서다 , 햇갈리면 그림을 그려보자
~~~

##3. BFS

1. 루트 노드에서 시작해서 **인접한 노드 먼저 탐색**
2. 시작 정점으로부터 가까운 정점 먼저 방문, 멀리 떨어져 있는 정점 나중에 방문하는 순회 방법
3. 깊게 말고 넓게 탐색 
4. **두 노드 사이의 최단 경로 혹은 임의의 경로 찾을 때 사용**
5. 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash 와 Vanessa 사이에 존재하는 경로를 찾는 경우
   - DFS : 모든 친구 관계 다 탐색할지도
   - BFS : ASH와 가까운 관계부터 탐색

#### 용도
- 웹 크롤링 - 동적으로 생성되는 무한한 페이지를 구글이 크롤링 하기 위해 BFS 사용
- 네트워크 브로드캐스트
- 가비지컬렉션

#### 장점
답이 여러개일때 최단경로 보장

#### 단점
경로 길 경우, 많은 기억 공간 필요로 함

#### 특징
  - 재귀적 동작 XXXXX

#### BFS 탐색 과정 & 소스

- 너비 우선 탐색
- 큐 이용
  - 1) 탐색 시작 노드를 큐에 삽입하고 방문 처리
  - 2) **큐에서 노드를 꺼낸 뒤에** 해당 노드의 인접 노드 중에서 방문하지 않았다면 노드 모두 큐에 삽입, 방문 처리
  - 3) 2번 과정 반복
  

~~~python
    from collections import deque

    def bfs(graph, start, visited):
        queue = deque([start])
        visited[start]= True

        while queue:
            # 출력
            v = queue.popleft()
            print(v, end=' ')

            # 인접 노드 삽입
            for i in graph[v]:
                if not visited[i]:
                    queue.append(i)
                    visited[i]=True

    graph = [
      [],
      [2, 3, 8],
      [1, 7],
      [1, 4, 5],
      [3, 5],
      [3, 4],
      [7],
      [2, 6, 8],
      [1, 7]
    ]  # 1 2 3 8 7 4 5 6

    #각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
    visited = [False] * 9

    bfs(graph, 1, visited) # 1 2 3 8 7 4 5 6
~~~

## 4 DFS BFS 해결

최단거리 ->  BFS
이동할 때마다 가중치 붙거나 이동 과정에 제약 있으면 -> DFS